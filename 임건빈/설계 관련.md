
---

## 기능 명세서 및 우선순위 설계

단순히 나열하지 말고 개발과 협업이 효율적으로 돌아가게 구조를 잡는 게 중요함

**우선순위 설정**

* **P0 (Critical):** 이거 없으면 서비스 출시 안 됨 


* **P1 (High):** 주요 기능이고 사용자 경험에 큰 영향 줌 


* **P2 (Medium):** 있으면 좋지만 다음 업데이트로 미룰 수 있음 


* **P3 (Low):** 사소한 개선이나 디테일 요소 



**세부 항목 분리**

* 기능명과 상세내용 사이에 **구분(세부 항목)** 컬럼을 하나 더 넣자
* 회원가입처럼 옵션이 많은 건 하나로 뭉치지 말고 일반 가입, 소셜 가입 등으로 쪼개야 우선순위 주기 편함
* 입력값(Input)이랑 상황별 로직(If-Else)을 딱 구분해서 적어줘야 개발자가 로직 설계할 때 실수가 없음

---

## 실시간 통신 및 기술 스택

Spring Boot로 실시간 상태 변화 보여주는 건 당연히 가능함

**구현 방식 선택**

* **WebSocket (STOMP):** 채팅이나 실시간 차트처럼 양방향 통신 필요할 때 씀
* **SSE (Server-Sent Events):** 알림이나 배달 상태처럼 서버가 일방적으로 밀어줄 때 씀, 구현이 더 쉬움
* **LiveKit (WebRTC):** 실시간 통화 세션이랑 룸 관리용으로 사용함

---

## 핵심 도메인 로직: 상담원 보호 서비스

PDF 명세서와 이미지 내용을 바탕으로 실제 구현할 때 챙겨야 할 포인트임 

**고객 접수 및 연결**

* **QR 접속:** 유효한 QR인지 먼저 체크하고 정보 입력창 띄우기 


* **고객 정보:** 접수 시 입력한 데이터(모델명, 증상)를 상담원 화면에 바로 매핑하기 


* **통화 종료:** 세션 끊기면 바로 상담 기록 단계로 강제 이동시켜서 데이터 유실 막기 



**음성 및 STT 처리**

* **음성 마스킹:** 욕설 들리면 실시간으로 삐- 소리 합성해서 상담원 귀 보호하기 


* **원본 저장:** 마스킹 전 원본은 증거용으로 S3 같은 보안 저장소에 따로 보관하기 


* **텍스트 블러:** STT로 변환된 텍스트 중 욕설은 스포일러 처리하고 클릭할 때만 보이게 하기 


* **타임스탬프:** 누가 언제 말했는지 화자 구분해서 타임라인 찍어주기 



**상담 지원 및 사후 관리**

* **제품 가이드:** 에러 코드(E1, F1 등) 인식해서 관련 수리 매뉴얼 자동 팝업 


* **RAG 검색:** 매뉴얼 데이터 벡터화해서 상담원 질문에 AI가 답변 찾기 


* **AI 요약:** 상담 끝나면 전체 대화 요약해서 고객한테 알림톡 발송하기 


* **성능 목표:** 음성 마스킹은 1초 이내, STT는 2초 이내로 지연 시간 줄이기 



---

**회원 관리 및 보안**

* **권한 분리:** 상담원과 중앙 관리자 계정 엄격히 구분해서 접근 제어하기 


* **JWT 인증:** 로그인 시 토큰 발급하고 모든 API 요청이랑 LiveKit 연결에 사용하기 

---

# 📌 REST API & 백엔드 설계 핵심 정리

---

## HTTP Method 의미

GET / POST / PUT / PATCH / DELETE 는
URL이 아니라 **행위의 의미를 Method로 표현하는 게 핵심**이다

### GET

조회 전용

서버 상태를 바꾸면 안 됨 (Safe)

같은 요청을 여러 번 해도 결과만 달라질 수 있고, 데이터는 변하면 안 됨

예시

* 단건 조회
* 목록 조회
* 검색 / 필터링

---

### POST

새 리소스 생성 또는 “행위” 실행

서버 상태가 바뀜

요청 body에 생성할 데이터 포함

예시

* 회원가입
* 리뷰 작성
* 로그인 (리소스 생성은 아니지만 액션이므로 POST 사용)

---

### PUT

전체 수정 (Replace 개념)

기존 데이터를 통째로 덮어쓴다는 의미

요청 body에 전체 필드를 보내는 게 원칙

실무에서는 필드 누락 시 데이터 날아갈 위험 있어서 잘 안 씀

---

### PATCH

부분 수정 (Partial Update)

수정할 필드만 보내면 됨

실무에서 가장 많이 쓰는 수정 방식

예시

* 닉네임 변경
* 상태값 변경

---

### DELETE

리소스 삭제

복구 불가능한 행위

삭제 대상은 반드시 ID로 특정 가능해야 함

---

## URL 설계 규칙 (REST 스타일)

URL은 **명사**, 행위는 **Method**

---

### 컬렉션 / 단일 리소스 구분

컬렉션

* `/users`
* `/realty`
* `/reviews`

단일 리소스

* `/users/{id}`
* `/reviews/{reviewId}`

Method로 동작 결정

* GET /users
* POST /users
* GET /users/1
* PATCH /users/1
* DELETE /users/1

---

### 관계 표현 (중첩 리소스)

부모 → 자식 관계 표현할 때만 사용

예시

`/realty/{id}/reviews`

의미

* 특정 매물에 속한 리뷰들

사용 예

* GET /realty/5/reviews
* POST /realty/5/reviews

리뷰 수정 / 삭제는

* PATCH /reviews/{reviewId}
* DELETE /reviews/{reviewId}

처럼 **리소스 단위로 분리하는 게 깔끔**

---

### URL 네이밍 규칙

동사 쓰지 말 것

* `/users/create` ❌
* `/users/{id}/update` ❌

대신

* POST /users
* PATCH /users/{id}

소문자 + 복수형 권장

* `/users`
* `/reviews`

조건 검색은 쿼리스트링

* `/realty?region=부산&minArea=20&sort=price,asc&page=2`

---

## Request / Response DTO 분리

엔티티(Entity)를 그대로 API에 쓰면 거의 무조건 나중에 터진다

그래서 **요청용 DTO / 응답용 DTO는 반드시 분리**

---

### 왜 분리해야 하냐면

보안 문제

* password, token 같은 값 노출 위험

구조 변경 대응

* DB 구조 바뀐다고 API 스펙이 같이 바뀌면 안 됨

검증 로직 분리

* Request는 validation 집중
* Response는 출력 포맷 집중

---

### Request DTO

클라이언트가 보내는 데이터 형식

입력에 필요한 것만 포함

예시

* UserCreateRequest
* UserUpdateRequest
* PasswordChangeRequest

---

### Response DTO

클라이언트에게 보여줄 데이터 형식

노출 가능한 정보만 포함

예시

* UserResponse
* RealtyResponse
* ReviewResponse

password, 내부 상태값, 삭제 플래그 같은 건 절대 포함 X

---

## 상태 코드 사용 기준

성공 / 실패를 **숫자로 명확하게 표현하는 게 목적**

---

### 200 OK

정상 처리

조회, 수정, 삭제 성공 시 대부분 사용

---

### 201 Created

리소스 생성 성공

POST로 새로운 데이터 만들어졌을 때

회원가입, 리뷰 작성 등

---

### 400 Bad Request

요청 자체가 잘못됨

형식 오류, 검증 실패, 필수값 누락

예시

* 이메일 형식 오류
* 값 범위 초과
* 조건 논리 오류

---

### 401 Unauthorized

인증 실패

토큰 없음, 만료, 위조

로그인 안 된 상태

---

### 403 Forbidden

인증은 됐는데 권한이 없음

예시

* 관리자 전용 API 접근
* 내 글 아닌데 삭제 시도

---

### 404 Not Found

리소스가 존재하지 않음

없는 유저, 없는 리뷰, 없는 매물

---

### 500 Internal Server Error

서버 코드 문제

NullPointer, DB 에러, 예외 처리 누락 등

실무에서는 500 최대한 줄이는 게 목표

---

## REST API 설계 흐름 

순서에 집착할 필요는 없지만, 보통 이렇게 감

---

### 1. 요구사항 정리

사용자 시나리오

* 누가
* 무엇을
* 왜 하는지

---

### 2. 기능 명세

기능 단위로 분해

* 로그인
* 매물 검색
* 리뷰 작성
* 즐겨찾기

---

### 3. ERD 설계

테이블 구조

관계, FK, 무결성 규칙

---

### 4. URL + Method 설계

리소스 단위로 API 설계

---

### 5. DTO 설계

Request / Response 분리

---

### 6. 상태 코드 / 예외 정책 결정

공통 응답 구조 정리

---
