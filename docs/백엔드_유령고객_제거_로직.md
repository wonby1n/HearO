# 백엔드 유령 고객 제거 로직 설계

## 문제 상황

### 발생 현상
상담사가 매칭되어 통화 화면에 진입했으나, 고객이 방에 입장하지 않는 현상 발생.

### 로그 증거
```
[STOMP] 매칭 배정: {type: 'MATCH_ASSIGNED', registrationId: 18, customerId: 1, ...}
[CounselorCallView] 고객 아직 미입장 - ParticipantConnected 대기
```

- 첫 번째 매칭: customerId: 17 → 정상
- 두 번째 매칭: customerId: 19 → 정상
- 세 번째 매칭: **customerId: 1** → 고객 미입장 (유령 고객)

### 원인 분석
Redis 대기열(queue:normal, queue:blacklist)에 "유령 고객"이 남아있음.

**유령 고객 발생 시나리오:**
1. 고객이 대기열 등록 후 브라우저를 닫음
2. 고객이 대기 화면에서 이탈 (뒤로가기, 탭 닫기)
3. 고객의 네트워크 연결 끊김
4. 테스트 데이터 잔류

---

## 현재 코드 분석

### 대기열 등록 (QueueServiceImpl.java)
```java
@Override
public QueueStatusResponse enqueue(String customerId) {
    // 중복 체크는 있음 (같은 고객 재등록 방지)
    Optional<QueueType> existingQueue = getQueueType(customerId);
    if (existingQueue.isPresent()) {
        return QueueStatusResponse.of(customerId, rank, existingQueue.get().name());
    }
    // 대기열 추가
    zSetOps.add(NORMAL_QUEUE_KEY, customerId, score);
}
```

### 매칭 스케줄러 (MatchingScheduler.java)
```java
@Scheduled(fixedRate = 5000)
public void executeMatching() {
    // 대기열에서 고객을 꺼내 매칭
    PopResult result = queueService.popMatchable(currentAvailable);
    // 매칭 알림 전송
    sendMatchingNotifications(result.customerId(), selectedCounselor, roomName);
}
```

### 문제점
- 고객이 **실제로 WebSocket에 연결되어 있는지** 확인하지 않음
- 대기열에 **TTL(만료 시간)** 없음
- 고객 **heartbeat** 없음

---

## 해결 방안

### 방안 1: 고객 Heartbeat (권장)

고객이 대기 중임을 주기적으로 알리고, 응답 없으면 대기열에서 제거.

#### 구현 위치
- `QueueService` - heartbeat 갱신/만료 체크 메서드 추가
- `QueueController` - heartbeat 엔드포인트 추가
- 새 스케줄러 - 만료된 고객 정리

#### 구현 예시

**Redis 키 구조:**
```
queue:heartbeat:{customerId} = timestamp (TTL: 30초)
```

**QueueService 추가 메서드:**
```java
// 고객 heartbeat 갱신
public void refreshHeartbeat(String customerId) {
    String key = "queue:heartbeat:" + customerId;
    redisTemplate.opsForValue().set(key, String.valueOf(System.currentTimeMillis()));
    redisTemplate.expire(key, Duration.ofSeconds(30));
}

// heartbeat 만료된 고객 제거
public List<String> removeExpiredCustomers() {
    List<String> removed = new ArrayList<>();

    // Normal Queue 체크
    Set<String> normalCustomers = redisTemplate.opsForZSet().range(NORMAL_QUEUE_KEY, 0, -1);
    for (String customerId : normalCustomers) {
        if (!hasValidHeartbeat(customerId)) {
            redisTemplate.opsForZSet().remove(NORMAL_QUEUE_KEY, customerId);
            removed.add(customerId);
            log.info("유령 고객 제거 (Normal): {}", customerId);
        }
    }

    // Blacklist Queue도 동일하게 처리
    // ...

    return removed;
}

private boolean hasValidHeartbeat(String customerId) {
    String key = "queue:heartbeat:" + customerId;
    return Boolean.TRUE.equals(redisTemplate.hasKey(key));
}
```

**QueueController 추가:**
```java
@PostMapping("/heartbeat")
public ResponseEntity<Void> heartbeat(@RequestParam String customerId) {
    queueService.refreshHeartbeat(customerId);
    return ResponseEntity.ok().build();
}
```

**정리 스케줄러:**
```java
@Scheduled(fixedRate = 10000) // 10초마다
public void cleanupExpiredCustomers() {
    List<String> removed = queueService.removeExpiredCustomers();
    if (!removed.isEmpty()) {
        log.info("유령 고객 {}명 정리됨: {}", removed.size(), removed);
    }
}
```

**프론트엔드 (ClientWaitingView.vue):**
```javascript
// 10초마다 heartbeat 전송
const heartbeatInterval = setInterval(() => {
    fetch(`/api/v1/queue/heartbeat?customerId=${customerId}`, { method: 'POST' })
}, 10000)

onUnmounted(() => {
    clearInterval(heartbeatInterval)
})
```

---

### 방안 2: 매칭 전 WebSocket 연결 확인

매칭 스케줄러에서 고객을 매칭하기 전에 WebSocket 연결 상태 확인.

#### 구현 위치
- `QueueWebSocketHandler` - 연결된 고객 ID 관리
- `MatchingScheduler` - 매칭 전 연결 상태 확인

#### 구현 예시

**QueueWebSocketHandler 수정:**
```java
private static final Set<String> connectedCustomers = ConcurrentHashMap.newKeySet();

@Override
public void afterConnectionEstablished(WebSocketSession session) {
    String customerId = extractCustomerId(session);
    if (customerId != null) {
        connectedCustomers.add(customerId);
    }
}

@Override
public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
    String customerId = extractCustomerId(session);
    if (customerId != null) {
        connectedCustomers.remove(customerId);
    }
}

public static boolean isConnected(String customerId) {
    return connectedCustomers.contains(customerId);
}
```

**MatchingScheduler 수정:**
```java
// popMatchable 호출 전에 연결 상태 확인
PopResult result = queueService.popMatchable(currentAvailable);

if (result.hasMatch()) {
    // 연결 상태 확인
    if (!QueueWebSocketHandler.isConnected(result.customerId())) {
        log.warn("유령 고객 감지 (WebSocket 미연결): {}", result.customerId());
        // 대기열에서 완전히 제거하고 다음 고객으로
        queueService.remove(result.customerId());
        continue; // 다음 매칭 시도
    }

    // 정상 매칭 진행
    // ...
}
```

---

### 방안 3: 대기열 TTL 설정 (간단한 방법)

대기열 등록 시 일정 시간이 지나면 자동 만료.

#### 구현 예시

**대기열 만료 스케줄러:**
```java
@Scheduled(fixedRate = 60000) // 1분마다
public void expireOldQueueEntries() {
    long expireThreshold = System.currentTimeMillis() - (5 * 60 * 1000); // 5분 전

    // score(timestamp)가 5분 이상 된 항목 제거
    redisTemplate.opsForZSet().removeRangeByScore(NORMAL_QUEUE_KEY, 0, expireThreshold);
    redisTemplate.opsForZSet().removeRangeByScore(BLACKLIST_QUEUE_KEY, 0, expireThreshold);

    log.info("5분 이상 대기한 고객 자동 만료 처리 완료");
}
```

**주의:** 이 방법은 실제로 대기 중인 고객도 5분 후 만료시킴. 상담 대기 시간이 길 수 있다면 부적합.

---

## 권장 구현 순서

1. **즉시 적용 (임시)**: Redis 수동 정리
   ```bash
   docker exec -it redis redis-cli ZREM queue:normal "1"
   docker exec -it redis redis-cli ZREM queue:normal "customer_1"
   ```

2. **1차 구현**: 방안 2 (WebSocket 연결 확인)
   - 구현 난이도: 낮음
   - 효과: 매칭 시점에 유령 고객 차단

3. **2차 구현**: 방안 1 (Heartbeat)
   - 구현 난이도: 중간
   - 효과: 실시간 유령 고객 제거

---

## 테스트 시나리오

| 시나리오 | 예상 결과 |
|---------|---------|
| 고객이 대기 중 브라우저 닫음 | 30초 후 대기열에서 제거됨 |
| 고객이 대기 중 네트워크 끊김 | 30초 후 대기열에서 제거됨 |
| 고객이 정상 대기 | heartbeat 갱신되어 대기열 유지 |
| 유령 고객 매칭 시도 | WebSocket 미연결로 매칭 거부, 다음 고객으로 |

---

## 관련 파일

- `backend/src/main/java/com/ssafy/hearo/domain/queue/service/QueueServiceImpl.java`
- `backend/src/main/java/com/ssafy/hearo/domain/queue/websocket/QueueWebSocketHandler.java`
- `backend/src/main/java/com/ssafy/hearo/domain/matching/service/MatchingScheduler.java`
- `frontend/src/views/client/ClientWaitingView.vue`
